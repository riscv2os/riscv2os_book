# 開放電腦計畫 -- 自制 RISC-V 電腦與作業系統

* [1. 簡介 -- 自制 RISC-V 處理器與作業系統](1.0.md)
    * [1.1 RISC-V 與開源硬體的概念](1.1.md)
    * [1.2 為什麼選擇自制 CPU 與作業系統？](1.2.md)
    * [1.3 本書的目標與範疇](1.3.md)
    * [1.4 硬體與軟體的分工與整合](1.4.md)
    * [1.5 設計與實現的挑戰](1.5.md)

* [2. RISC-V 的組合語言 (ASM + RISC-V tool chain)](2.0.md)
    * [2.1 組合語言的基本概念](2.1.md)
    * [2.2 RISC-V 指令集架構 (ISA) 概述](2.2.md)
    * [2.3 使用 RISC-V 工具鏈 (gcc、assembler、linker、simulator)](2.3.md)
    * [2.4 撰寫與執行 RISC-V 組合語言程式](2.4.md)
    * [2.5 效能與最佳化技巧](2.5.md)

* [3. 自制嵌入式 RISC-V 作業系統 (C + ASM)](3.0.md)
    * [3.1 嵌入式作業系統的基本結構](3.1.md)
    * [3.2 在 RISC-V 裸機上面透過 UART 印出 Hello](3.2.md)
    * [3.3 RISC-V 的內文切換](3.3.md)
    * [3.4 RISC-V 的協同式多工系統](3.4.md)
    * [3.5 RISC-V 的時間中斷處理](3.5.md)
    * [3.6 RISC-V 的可搶先多工系統](3.6.md)
    * [3.7 mini-riscv-os 專案](3.7.md)

* [4. 自制單週期的 RISC-V 處理器 (Verilog + Icarus)](4.0.md)
    * [4.1 Verilog 基礎與設計流程](4.1.md)
    * [4.2 RISC-V 單週期處理器的原理](4.2.md)
    * [4.3 RISC-V CPU 模組的 Verilog 實現](4.3.md)
    * [4.4 加上記憶體形成完整系統](4.4.md)
    * [4.5 使用 Icarus Verilog 進行模擬與驗證](4.5.md)
    * [4.6 mini-riscv-cpu 專案](4.6.md)

* [5. 自制五階段管線的 RISC-V 處理器 (Verilog + Verilator)](5.0.md)
    * [5.1 管線化處理器的基本概念](5.1.md)
    * [5.2 五階段管線的架構](5.2.md)
    * [5.3 基本模組 (alu / busio / cmp / csr / regfile / busio)](5.3.md)
    * [5.4 管線模組 (fetch / decode / execute / memory / writeback)](5.4.md)
    * [5.5 使用 Verilator 模擬與驗證](5.5.md)
    * [5.6 kleine-riscv 專案](5.6.md)

* [6. 類 UNIX 的 xv6 作業系統 (C + ASM)](6.0.md)
    * [6.1 xv6 作業系統架構簡介](6.1.md)
    * [6.2 xv6 的啟動程式與初始化流程](6.2.md)
    * [6.3 xv6 的行程管理與排程機制](6.3.md)
    * [6.4 xv6 的虛擬記憶體與分頁技術](6.4.md)
    * [6.5 xv6 的設備驅動程式](6.5.md)
    * [6.6 xv6 的檔案系統](6.6.md)
    * [6.7 xv6 與 MIT 6.1810 課程](6.7.md)

* [7. 從 RISC-V CPU 到 xv6 作業系統串起資工系的課程](7.0.md)
    * [7.1 重理論輕實作的資工系大學課程](7.1.md)
    * [7.2 RISC-V: 從數位邏輯到計算機結構](7.2.md)
    * [7.3 xv6: 從系統程式到作業系統](7.3.md)
    * [7.4 尚未串起的那些主題與專案（編譯器 c4 / 虛擬機 semu / 網路堆疊 nstack / 人工智慧 llm.c / 視窗 mado)](7.4.md)
    * [7.5 開放電腦計畫的未來 (更多專案，開源 EDA / RISC-V CPU tapeout)](7.5.md)
