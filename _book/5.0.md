### 5. 自制五階段管線的 RISC-V 處理器 (Verilog + Verilator)

在這一章中，我們將探討如何設計一個五階段管線的 RISC-V 處理器。管線化是一種提高處理器效能的技術，能夠在同一時間處理多條指令，從而增強整體吞吐量。本章將涵蓋管線的基本概念、架構、各個模組的實現以及使用 Verilator 進行模擬和驗證。

#### 5.1 管線化處理器的基本概念

管線化處理器的設計靈感來自於工廠生產線，將指令的執行過程劃分為幾個階段，使得每個階段都能並行運作。RISC-V 的五階段管線包括：

1. **取指階段 (IF)**：從記憶體中獲取指令。
2. **指令解碼階段 (ID)**：解碼指令並讀取所需的暫存器。
3. **執行階段 (EX)**：執行 ALU 操作。
4. **存取記憶體階段 (MEM)**：對記憶體進行讀取或寫入操作。
5. **寫回階段 (WB)**：將結果寫回暫存器檔。

#### 5.2 五階段管線的架構

五階段管線的架構設計如下：

```
+-----+-----+-----+-----+-----+
| IF  | ID  | EX  | MEM | WB  |
+-----+-----+-----+-----+-----+
|     |     |     |     |     |
|  A  |  B  |  C  |  D  |  E  |
+-----+-----+-----+-----+-----+
```

在這個架構中，指令 A、B、C、D、E 在不同的階段中並行運行，這樣可以顯著提高處理器的效率。

#### 5.3 基本模組 (ALU / busio / cmp / csr / regfile / busio)

**5.3.1 ALU 模組**

ALU 模組與之前的單週期處理器相似，但在管線化設計中，ALU 的輸入和輸出將在 EX 階段進行更新。以下是 ALU 模組的基本結構：

```verilog
module alu (
    input [31:0] A,
    input [31:0] B,
    input [3:0] ALU_control,
    output reg [31:0] ALU_result
);
    always @(*) begin
        case (ALU_control)
            4'b0000: ALU_result = A + B; // 加法
            4'b0001: ALU_result = A - B; // 減法
            // 其他運算...
            default: ALU_result = 0;
        endcase
    end
endmodule
```

**5.3.2 Bus I/O 模組**

Bus I/O 模組用於處理資料傳輸。這是一個簡化的 Bus 模組：

```verilog
module busio (
    input [31:0] data_in,
    output reg [31:0] data_out,
    input enable
);
    always @(*) begin
        if (enable)
            data_out = data_in;
        else
            data_out = 32'bz; // 高阻態
    end
endmodule
```

**5.3.3 比較器 (Comparator)**

比較器模組用於比較兩個數值，並返回結果：

```verilog
module cmp (
    input [31:0] A,
    input [31:0] B,
    output reg equal,
    output reg less_than
);
    always @(*) begin
        equal = (A == B);
        less_than = (A < B);
    end
endmodule
```

**5.3.4 控制與狀態暫存器 (CSR)**

CSR 模組用於管理處理器的狀態與控制：

```verilog
module csr (
    input clk,
    input reset,
    output reg [31:0] status
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            status <= 0;
        else
            // 根據控制信號更新狀態
            status <= status + 1;
    end
endmodule
```

**5.3.5 暫存器檔模組**

暫存器檔用於儲存運算的資料，結構如下：

```verilog
module regfile (
    input clk,
    input reg_write,
    input [4:0] reg_write_addr,
    input [31:0] reg_write_data,
    output [31:0] reg_read_data1,
    output [31:0] reg_read_data2,
    input [4:0] reg_read_addr1,
    input [4:0] reg_read_addr2
);
    reg [31:0] registers [31:0];

    always @(posedge clk) begin
        if (reg_write)
            registers[reg_write_addr] <= reg_write_data;
    end

    assign reg_read_data1 = registers[reg_read_addr1];
    assign reg_read_data2 = registers[reg_read_addr2];
endmodule
```

#### 5.4 Pipeline 管線模組 (fetch / decode / execute / memory / writeback)

每一階段的設計都需要明確的介面，以便資料可以在不同階段之間流動。以下是五個主要管線階段的模組結構。

**5.4.1 取指階段 (IF)**

取指階段模組將負責從記憶體讀取指令並將其傳遞至下一階段：

```verilog
module fetch (
    input clk,
    input reset,
    output [31:0] instruction
);
    // 實現取指邏輯
endmodule
```

**5.4.2 解碼階段 (ID)**

解碼階段模組將指令解碼並準備所需的資料：

```verilog
module decode (
    input [31:0] instruction,
    output [4:0] rs1,
    output [4:0] rs2,
    output [4:0] rd,
    output [3:0] ALU_control
);
    // 實現解碼邏輯
endmodule
```

**5.4.3 執行階段 (EX)**

執行階段將處理指令的運算：

```verilog
module execute (
    input [31:0] rs1_data,
    input [31:0] rs2_data,
    input [3:0] ALU_control,
    output [31:0] ALU_result
);
    // 實現運算邏輯
endmodule
```

**5.4.4 記憶體階段 (MEM)**

記憶體階段將執行讀寫操作：

```verilog
module memory_access (
    input [31:0] ALU_result,
    input [31:0] write_data,
    output [31:0] read_data
);
    // 實現記憶體操作邏輯
endmodule
```

**5.4.5 寫回階段 (WB)**

寫回階段將結果寫回暫存器檔：

```verilog
module write_back (
    input clk,
    input [31:0] ALU_result,
    output [31:0] write_data
);
    // 實現寫回邏輯
endmodule
```

#### 5.5 使用 Verilator 模擬與驗證

Verilator 是一個開源的 Verilog 模擬器，可以將 Verilog 代碼轉換為 C++ 代碼，以便進行高效的模擬。以下是使用 Verilator 進行模擬的步驟：

1. **撰寫測試平台**：根據設計，撰寫測試平台以模擬指令的執行。
2. **編譯代碼**：使用 Verilator 將 Verilog 代碼編譯為 C++ 代碼。
3. **執行模擬**：運行生成的可執行文件，驗證輸出是否符合預期。

以下是一個簡單的測試平台範例：

```verilog
module tb_pipeline;
    reg clk;
    reg reset;
    wire [31:0] result;

    // 實例化五階段管線處理器
    five_stage_pipeline uut (
        .clk(clk),
        .reset(reset),
        .result(result)
    );

    // 時鐘生成
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 每 5 單位時間反轉時鐘
    end

    // 測試序列
    initial begin
        reset = 1;
        #10;
        reset = 0

;

        // 添加測試向量
        // 驗證結果

        $finish; // 結束模擬
    end
endmodule
```

#### 5.6 小結

在這一章中，我們詳細介紹了如何設計一個五階段管線的 RISC-V 處理器。通過將指令的執行過程分為多個階段，我們能夠提高處理器的效率，並學會如何使用 Verilator 進行模擬和驗證。接下來的章節將進一步探討更複雜的處理器設計，例如支援更高級功能的處理器架構。