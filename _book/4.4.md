### 4.4 加上記憶體形成完整系統

在這一節中，我們將探討如何將前面實現的 RISC-V 處理器模組與記憶體模組結合，形成一個完整的系統。這個系統將包括指令記憶體和資料記憶體，並能夠執行儲存在指令記憶體中的程序，同時進行資料的讀取與寫入。

#### 1. 系統架構概述

完整的 RISC-V 處理器系統通常包含以下主要部分：

- **指令記憶體 (Instruction Memory)**：存儲要執行的指令。
- **資料記憶體 (Data Memory)**：存儲執行過程中所需的數據。
- **CPU**：執行指令的核心模組，包含 ALU、寄存器檔和控制單元。
- **PC (Program Counter)**：指向下一條要執行的指令的地址。

這些部分通過適當的總線相連，以實現數據和指令的交換。

#### 2. 設計完整系統

以下是我們的系統設計，包括 PC 管理和指令/數據存取的整合。

```verilog
module riscv_system (
	input clk,
	input reset
);
	wire [31:0] instruction;        // 從指令記憶體讀取的指令
	wire [31:0] read_data;          // 從資料記憶體讀取的數據
	wire [31:0] alu_result;         // ALU 的計算結果
	wire [31:0] read_data1, read_data2; // 來自寄存器檔的數據
	wire reg_write, mem_read, mem_write;
	wire [3:0] alu_control;
	wire [4:0] write_reg;
	reg [31:0] pc;                  // 程序計數器

	// 指令記憶體實例化
	instruction_memory im (
		.address(pc),               // 根據 PC 的值讀取指令
		.instruction(instruction)
	);

	// 資料記憶體實例化
	data_memory dm (
		.clk(clk),
		.address(alu_result),       // ALU 的結果作為地址
		.write_data(read_data2),    // 從寄存器檔讀取的數據
		.mem_read(mem_read),        // 設置讀取信號
		.mem_write(mem_write),      // 設置寫入信號
		.read_data(read_data)       // 從記憶體讀取的數據
	);

	// 寄存器檔實例化
	register_file rf (
		.clk(clk),
		.read_reg1(instruction[19:15]), // 從指令中提取的寄存器索引
		.read_reg2(instruction[24:20]),
		.write_reg(write_reg),         // 寫入寄存器的索引
		.write_data(alu_result),       // ALU 的結果作為寫入數據
		.reg_write(reg_write),         // 控制寫入信號
		.read_data1(read_data1),      // 讀取的數據
		.read_data2(read_data2)
	);

	// ALU 實例化
	alu alu (
		.input1(read_data1),         // 來自寄存器檔的數據
		.input2(read_data2),
		.alu_control(alu_control),    // ALU 控制信號
		.result(alu_result)           // ALU 計算結果
	);

	// 控制單元實例化
	control_unit cu (
		.opcode(instruction[6:0]),   // 從指令中提取的操作碼
		.reg_write(reg_write),
		.mem_read(mem_read),
		.mem_write(mem_write),
		.alu_control(alu_control)
	);

	// 程序計數器的管理
	always @(posedge clk or posedge reset) begin
		if (reset) begin
			pc <= 0;                   // 重置 PC
		end else begin
			pc <= pc + 4;              // 每次時鐘上升沿將 PC 加 4，指向下一條指令
		end
	end

	// 輸出最終的計算結果
	assign result = alu_result;

endmodule
```

#### 3. 系統的運作流程

整個系統的運作過程如下：

1. **重置**：在系統啟動時，程序計數器 (PC) 被初始化為 0。
2. **指令取出**：每個時鐘周期，根據 PC 的值從指令記憶體中讀取指令，並將其送入 CPU 的指令解碼階段。
3. **指令解碼**：控制單元解析指令，生成控制信號以指導 CPU 的操作，包括寄存器檔的讀取、ALU 的運算及資料記憶體的存取。
4. **運算執行**：ALU 根據控制信號執行相應的運算。
5. **數據存取**：如果需要，CPU 可以從資料記憶體中讀取或寫入數據。
6. **更新 PC**：PC 在每次時鐘上升沿後自動更新，指向下一條要執行的指令。

### 小結

在本節中，我們展示了如何將 RISC-V 處理器的各個組件結合成一個完整的系統，包括指令記憶體和資料記憶體的整合。透過這個系統，使用者可以載入和執行 RISC-V 指令，並在執行過程中進行數據的讀取和寫入。在接下來的章節中，我們將學習如何使用 Icarus Verilog 進行模擬和驗證這個系統的運作。