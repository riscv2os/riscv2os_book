### 4.6 mini-riscv-cpu 專案

在這一節中，我們將詳細介紹 **mini-riscv-cpu** 專案，這是一個基於 RISC-V 架構的簡化處理器實現。此專案旨在提供一個簡單而易於理解的 RISC-V 處理器設計，並展示如何將之前所學的知識整合在一起。

#### 1. 專案概述

**mini-riscv-cpu** 專案是一個小型的 RISC-V 處理器實現，使用 Verilog 語言編寫。該專案主要針對教育目的，旨在幫助學習者了解 RISC-V 處理器的基本結構和運作原理。專案包含以下主要組件：

- **控制單元**：負責生成控制信號，指導其他組件的運作。
- **運算邏輯單元（ALU）**：執行算術和邏輯運算。
- **暫存器檔**：用於儲存運算的中間結果和指令。
- **記憶體單元**：用於讀取和寫入資料。

#### 2. 專案架構

專案的基本架構如下：

```
mini-riscv-cpu
├── src                  # 原始碼目錄
│   ├── alu.v           # ALU 模組
│   ├── regfile.v       # 暫存器檔模組
│   ├── control.v       # 控制單元模組
│   ├── cpu.v           # 處理器頂層模組
│   └── memory.v        # 記憶體模組
└── testbench            # 測試平台
	└── tb_cpu.v        # 處理器測試平台
```

#### 3. 主要組件

**3.1 ALU 模組**

ALU 模組是處理器的核心，用於執行各種算術和邏輯運算。以下是一個簡化的 ALU 實現：

```verilog
module alu (
	input [31:0] A, 
	input [31:0] B,
	input [3:0] ALU_control,
	output reg [31:0] ALU_result
);
	always @(*) begin
		case (ALU_control)
			4'b0000: ALU_result = A + B;      // 加法
			4'b0001: ALU_result = A - B;      // 減法
			4'b0010: ALU_result = A & B;      // 位元與
			4'b0011: ALU_result = A | B;      // 位元或
			// 其他運算...
			default: ALU_result = 0;
		endcase
	end
endmodule
```

**3.2 控制單元模組**

控制單元負責根據指令生成控制信號，以指導 ALU 和其他模組的運作。以下是一個簡化的控制單元實現：

```verilog
module control (
	input [6:0] opcode,
	output reg [3:0] ALU_control,
	output reg reg_write
);
	always @(*) begin
		case (opcode)
			7'b0110011: begin // R-type 指令
				ALU_control = 4'b0000; // 加法
				reg_write = 1;
			end
			// 其他指令...
			default: begin
				ALU_control = 4'b0000;
				reg_write = 0;
			end
		endcase
	end
endmodule
```

**3.3 暫存器檔**

暫存器檔用於儲存處理器的暫存器資料。以下是一個簡化的暫存器檔實現：

```verilog
module regfile (
	input clk,
	input reg_write,
	input [4:0] reg_write_addr,
	input [31:0] reg_write_data,
	output [31:0] reg_read_data1,
	output [31:0] reg_read_data2,
	input [4:0] reg_read_addr1,
	input [4:0] reg_read_addr2
);
	reg [31:0] registers [31:0]; // 32 個 32 位元暫存器

	always @(posedge clk) begin
		if (reg_write) 
			registers[reg_write_addr] <= reg_write_data;
	end

	assign reg_read_data1 = registers[reg_read_addr1];
	assign reg_read_data2 = registers[reg_read_addr2];
endmodule
```

**3.4 記憶體模組**

記憶體模組用於實現讀取和寫入操作，以下是一個簡化的記憶體實現：

```verilog
module memory (
	input clk,
	input [31:0] addr,
	input [31:0] data_in,
	input mem_write,
	output reg [31:0] data_out
);
	reg [31:0] mem [0:1023]; // 1KB 記憶體

	always @(posedge clk) begin
		if (mem_write) 
			mem[addr] <= data_in;
	end

	always @(*) begin
		data_out = mem[addr];
	end
endmodule
```

#### 4. 測試平台

為了驗證 mini-riscv-cpu 的功能，我們需要一個測試平台。以下是一個簡單的測試平台範例，該平台將隨機生成指令並驗證處理器的行為：

```verilog
module tb_cpu;
	reg clk;
	reg reset;
	wire [31:0] result;

	// 實例化 CPU
	mini_riscv_cpu uut (
		.clk(clk),
		.reset(reset),
		.result(result)
	);

	// 時鐘生成
	initial begin
		clk = 0;
		forever #5 clk = ~clk; // 每 5 單位時間反轉時鐘
	end

	// 測試序列
	initial begin
		reset = 1;
		#10;
		reset = 0;

		// 在這裡添加更多測試向量
		// 檢查結果

		$finish; // 結束模擬
	end
endmodule
```

#### 5. 小結

mini-riscv-cpu 專案是一個簡化的 RISC-V 處理器實現，涵蓋了 RISC-V 的基本概念和模組化設計。透過這個專案，學習者可以深入了解處理器的內部運作，並學會如何將理論應用於實際的設計與實現中。接下來的章節將進一步探討更複雜的處理器設計，如五階段管線化處理器的實現。