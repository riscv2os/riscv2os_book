### 4.6 mini-riscv-cpu 專案

在這一節中，我們將詳細介紹 **mini-riscv-cpu** 專案，這是一個基於 RISC-V 架構的簡化處理器實現。此專案旨在提供一個簡單而易於理解的 RISC-V 處理器設計，並展示如何將之前所學的知識整合在一起。

#### 1. 專案概述

**mini-riscv-cpu** 專案是一個小型的 RISC-V 處理器實現，使用 Verilog 語言編寫。該專案主要針對教育目的，旨在幫助學習者了解 RISC-V 處理器的基本結構和運作原理。專案包含以下主要組件：

- **控制單元**：負責生成控制信號，指導其他組件的運作。
- **運算邏輯單元（ALU）**：執行算術和邏輯運算。
- **暫存器檔**：用於儲存運算的中間結果和指令。
- **記憶體單元**：用於讀取和寫入資料。

#### 2. 專案架構

專案的基本架構如下：

```
mini-riscv-cpu
├── src                  # 原始碼目錄
│   ├── alu.v           # ALU 模組
│   ├── regfile.v       # 暫存器檔模組
│   ├── control.v       # 控制單元模組
│   ├── cpu.v           # 處理器頂層模組
│   └── memory.v        # 記憶體模組
└── testbench            # 測試平台
    └── tb_cpu.v        # 處理器測試平台
```

#### 3. 主要組件

**3.1 ALU 模組**

ALU 模組是處理器的核心，用於執行各種算術和邏輯運算。以下是一個簡化的 ALU 實現：

```verilog
module alu (
    input [31:0] A, 
    input [31:0] B,
    input [3:0] ALU_control,
    output reg [31:0] ALU_result
);
    always @(*) begin
        case (ALU_control)
            4'b0000: ALU_result = A + B;      // 加法
            4'b0001: ALU_result = A - B;      // 減法
            4'b0010: ALU_result = A & B;      // 位元與
            4'b0011: ALU_result = A | B;      // 位元或
            // 其他運算...
            default: ALU_result = 0;
        endcase
    end
endmodule
```

**3.2 控制單元模組**

控制單元負責根據指令生成控制信號，以指導 ALU 和其他模組的運作。以下是一個簡化的控制單元實現：

```verilog
module control (
    input [6:0] opcode,
    output reg [3:0] ALU_control,
    output reg reg_write
);
    always @(*) begin
        case (opcode)
            7'b0110011: begin // R-type 指令
                ALU_control = 4'b0000; // 加法
                reg_write = 1;
            end
            // 其他指令...
            default: begin
                ALU_control = 4'b0000;
                reg_write = 0;
            end
        endcase
    end
endmodule
```

**3.3 暫存器檔**

暫存器檔用於儲存處理器的暫存器資料。以下是一個簡化的暫存器檔實現：

```verilog
module regfile (
    input clk,
    input reg_write,
    input [4:0] reg_write_addr,
    input [31:0] reg_write_data,
    output [31:0] reg_read_data1,
    output [31:0] reg_read_data2,
    input [4:0] reg_read_addr1,
    input [4:0] reg_read_addr2
);
    reg [31:0] registers [31:0]; // 32 個 32 位元暫存器

    always @(posedge clk) begin
        if (reg_write) 
            registers[reg_write_addr] <= reg_write_data;
    end

    assign reg_read_data1 = registers[reg_read_addr1];
    assign reg_read_data2 = registers[reg_read_addr2];
endmodule
```

**3.4 記憶體模組**

記憶體模組用於實現讀取和寫入操作，以下是一個簡化的記憶體實現：

```verilog
module memory (
    input clk,
    input [31:0] addr,
    input [31:0] data_in,
    input mem_write,
    output reg [31:0] data_out
);
    reg [31:0] mem [0:1023]; // 1KB 記憶體

    always @(posedge clk) begin
        if (mem_write) 
            mem[addr] <= data_in;
    end

    always @(*) begin
        data_out = mem[addr];
    end
endmodule
```

#### 4. 測試平台

為了驗證 mini-riscv-cpu 的功能，我們需要一個測試平台。以下是一個簡單的測試平台範例，該平台將隨機生成指令並驗證處理器的行為：

```verilog
module tb_cpu;
    reg clk;
    reg reset;
    wire [31:0] result;

    // 實例化 CPU
    mini_riscv_cpu uut (
        .clk(clk),
        .reset(reset),
        .result(result)
    );

    // 時鐘生成
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 每 5 單位時間反轉時鐘
    end

    // 測試序列
    initial begin
        reset = 1;
        #10;
        reset = 0;

        // 在這裡添加更多測試向量
        // 檢查結果

        $finish; // 結束模擬
    end
endmodule
```

#### 5. 小結

mini-riscv-cpu 專案是一個簡化的 RISC-V 處理器實現，涵蓋了 RISC-V 的基本概念和模組化設計。透過這個專案，學習者可以深入了解處理器的內部運作，並學會如何將理論應用於實際的設計與實現中。接下來的章節將進一步探討更複雜的處理器設計，如五階段管線化處理器的實現。