### 4.3 RISC-V CPU 模組的 Verilog 實現

在本節中，我們將深入探討如何使用 Verilog 實現一個基本的 RISC-V 單週期處理器的 CPU 模組。這個模組將包含所有必要的組件，包括指令記憶體、資料記憶體、寄存器檔、ALU 以及控制單元。我們會逐步介紹每個模組的功能和 Verilog 實現細節。

#### 1. CPU 模組的結構

一個典型的 RISC-V CPU 模組通常由以下幾個主要子模組組成：

- **指令記憶體模組（Instruction Memory）**
- **資料記憶體模組（Data Memory）**
- **寄存器檔模組（Register File）**
- **算術邏輯單元模組（ALU）**
- **控制單元模組（Control Unit）**

這些子模組共同工作，實現整個 RISC-V 處理器的功能。

#### 2. 指令記憶體模組

指令記憶體用於存儲待執行的指令。以下是 Verilog 的基本實現：

```verilog
module instruction_memory (
    input [31:0] address,
    output reg [31:0] instruction
);
    reg [31:0] memory [0:255];  // 假設記憶體大小為 256 個字

    initial begin
        // 載入指令到記憶體（這裡可以根據需要進行修改）
        memory[0] = 32'h00000013; // nop
        memory[1] = 32'h00000093; // li x1, 0
        // 其他指令...
    end

    always @(*) begin
        instruction = memory[address[7:2]]; // 根據地址讀取指令
    end
endmodule
```

#### 3. 資料記憶體模組

資料記憶體用於存儲執行過程中的數據，實現如下：

```verilog
module data_memory (
    input clk,
    input [31:0] address,
    input [31:0] write_data,
    input mem_read,
    input mem_write,
    output reg [31:0] read_data
);
    reg [31:0] memory [0:255]; // 假設記憶體大小為 256 個字

    always @(posedge clk) begin
        if (mem_write) begin
            memory[address[7:2]] <= write_data; // 寫入數據
        end
    end

    always @(*) begin
        if (mem_read) begin
            read_data = memory[address[7:2]]; // 讀取數據
        end
    end
endmodule
```

#### 4. 寄存器檔模組

寄存器檔用於存儲暫存數據，實現如下：

```verilog
module register_file (
    input clk,
    input [4:0] read_reg1,
    input [4:0] read_reg2,
    input [4:0] write_reg,
    input [31:0] write_data,
    input reg_write,
    output reg [31:0] read_data1,
    output reg [31:0] read_data2
);
    reg [31:0] registers [0:31]; // 32 個寄存器

    always @(posedge clk) begin
        if (reg_write) begin
            registers[write_reg] <= write_data; // 寫入數據
        end
    end

    always @(*) begin
        read_data1 = registers[read_reg1]; // 讀取寄存器1
        read_data2 = registers[read_reg2]; // 讀取寄存器2
    end
endmodule
```

#### 5. 算術邏輯單元模組

ALU 負責執行算術與邏輯操作，實現如下：

```verilog
module alu (
    input [31:0] input1,
    input [31:0] input2,
    input [3:0] alu_control,
    output reg [31:0] result,
    output reg zero
);
    always @(*) begin
        case (alu_control)
            4'b0000: result = input1 & input2; // AND
            4'b0001: result = input1 | input2; // OR
            4'b0010: result = input1 + input2; // ADD
            4'b0110: result = input1 - input2; // SUB
            // 其他運算...
            default: result = 0;
        endcase
        zero = (result == 0) ? 1 : 0; // 判斷是否為零
    end
endmodule
```

#### 6. 控制單元模組

控制單元負責生成控制信號以協調各組件的操作，實現如下：

```verilog
module control_unit (
    input [6:0] opcode,
    output reg reg_write,
    output reg mem_read,
    output reg mem_write,
    output reg [3:0] alu_control
);
    always @(*) begin
        case (opcode)
            7'b0110011: begin // R-type
                reg_write = 1;
                mem_read = 0;
                mem_write = 0;
                alu_control = 4'b0010; // ADD
            end
            7'b0000011: begin // Load
                reg_write = 1;
                mem_read = 1;
                mem_write = 0;
                alu_control = 4'b0010; // ADD
            end
            7'b0100011: begin // Store
                reg_write = 0;
                mem_read = 0;
                mem_write = 1;
                alu_control = 4'b0010; // ADD
            end
            // 其他操作...
            default: begin
                reg_write = 0;
                mem_read = 0;
                mem_write = 0;
                alu_control = 4'b0000; // NO OP
            end
        endcase
    end
endmodule
```

#### 7. 整合 CPU 模組

最後，我們將所有子模組整合到主 CPU 模組中：

```verilog
module riscv_cpu (
    input clk,
    input reset,
    output [31:0] result
);
    wire [31:0] instruction;
    wire [31:0] read_data1, read_data2;
    wire [31:0] alu_result;
    wire [31:0] read_data;
    wire reg_write, mem_read, mem_write;
    wire [3:0] alu_control;
    wire [4:0] write_reg;

    instruction_memory im (
        .address(pc), // 假設已經有 PC 管理
        .instruction(instruction)
    );

    data_memory dm (
        .clk(clk),
        .address(alu_result),
        .write_data(read_data2),
        .mem_read(mem_read),
        .mem_write(mem_write),
        .read_data(read_data)
    );

    register_file rf (
        .clk(clk),
        .read_reg1(instruction[19:15]),
        .read_reg2(instruction[24:20]),
        .write_reg(write_reg),
        .write_data(alu_result),
        .reg_write(reg_write),
        .read_data1(read_data1),
        .read_data2(read_data2)
    );

    alu alu (
        .input1(read_data1),
        .input2(read_data2),
        .alu_control(alu_control),
        .result(alu_result)
    );

    control_unit cu (
        .opcode(instruction[6:0]),
        .reg_write(reg_write),
        .mem_read(mem_read),
        .mem_write(mem_write),
        .alu_control(alu_control)
    );

    assign result = alu_result; // 輸出結果
endmodule
```

### 小結

在本節中，我們詳細介紹了如何使用 Verilog 實現 RISC-V 單週期處理器的各個組件，包括指令記憶體、資料記憶體、寄存器檔、ALU 和控制單元。透過這些模組的組合，形成了一個簡單的 CPU 模組，可以執行基本的 RISC-V 指令。在接下來的章節中，我們將探討如何利用 Icarus Verilog 對這個設計進行模擬和驗證。