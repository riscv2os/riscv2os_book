### 4.3 RISC-V CPU 模組的 Verilog 實現

在本節中，我們將深入探討如何使用 Verilog 實現一個基本的 RISC-V 單週期處理器的 CPU 模組。這個模組將包含所有必要的組件，包括指令記憶體、資料記憶體、寄存器檔、ALU 以及控制單元。我們會逐步介紹每個模組的功能和 Verilog 實現細節。

#### 1. CPU 模組的結構

一個典型的 RISC-V CPU 模組通常由以下幾個主要子模組組成：

- **指令記憶體模組（Instruction Memory）**
- **資料記憶體模組（Data Memory）**
- **寄存器檔模組（Register File）**
- **算術邏輯單元模組（ALU）**
- **控制單元模組（Control Unit）**

這些子模組共同工作，實現整個 RISC-V 處理器的功能。

#### 2. 指令記憶體模組

指令記憶體用於存儲待執行的指令。以下是 Verilog 的基本實現：

```verilog
module instruction_memory (
	input [31:0] address,
	output reg [31:0] instruction
);
	reg [31:0] memory [0:255];  // 假設記憶體大小為 256 個字

	initial begin
		// 載入指令到記憶體（這裡可以根據需要進行修改）
		memory[0] = 32'h00000013; // nop
		memory[1] = 32'h00000093; // li x1, 0
		// 其他指令...
	end

	always @(*) begin
		instruction = memory[address[7:2]]; // 根據地址讀取指令
	end
endmodule
```

#### 3. 資料記憶體模組

資料記憶體用於存儲執行過程中的數據，實現如下：

```verilog
module data_memory (
	input clk,
	input [31:0] address,
	input [31:0] write_data,
	input mem_read,
	input mem_write,
	output reg [31:0] read_data
);
	reg [31:0] memory [0:255]; // 假設記憶體大小為 256 個字

	always @(posedge clk) begin
		if (mem_write) begin
			memory[address[7:2]] <= write_data; // 寫入數據
		end
	end

	always @(*) begin
		if (mem_read) begin
			read_data = memory[address[7:2]]; // 讀取數據
		end
	end
endmodule
```

#### 4. 寄存器檔模組

寄存器檔用於存儲暫存數據，實現如下：

```verilog
module register_file (
	input clk,
	input [4:0] read_reg1,
	input [4:0] read_reg2,
	input [4:0] write_reg,
	input [31:0] write_data,
	input reg_write,
	output reg [31:0] read_data1,
	output reg [31:0] read_data2
);
	reg [31:0] registers [0:31]; // 32 個寄存器

	always @(posedge clk) begin
		if (reg_write) begin
			registers[write_reg] <= write_data; // 寫入數據
		end
	end

	always @(*) begin
		read_data1 = registers[read_reg1]; // 讀取寄存器1
		read_data2 = registers[read_reg2]; // 讀取寄存器2
	end
endmodule
```

#### 5. 算術邏輯單元模組

ALU 負責執行算術與邏輯操作，實現如下：

```verilog
module alu (
	input [31:0] input1,
	input [31:0] input2,
	input [3:0] alu_control,
	output reg [31:0] result,
	output reg zero
);
	always @(*) begin
		case (alu_control)
			4'b0000: result = input1 & input2; // AND
			4'b0001: result = input1 | input2; // OR
			4'b0010: result = input1 + input2; // ADD
			4'b0110: result = input1 - input2; // SUB
			// 其他運算...
			default: result = 0;
		endcase
		zero = (result == 0) ? 1 : 0; // 判斷是否為零
	end
endmodule
```

#### 6. 控制單元模組

控制單元負責生成控制信號以協調各組件的操作，實現如下：

```verilog
module control_unit (
	input [6:0] opcode,
	output reg reg_write,
	output reg mem_read,
	output reg mem_write,
	output reg [3:0] alu_control
);
	always @(*) begin
		case (opcode)
			7'b0110011: begin // R-type
				reg_write = 1;
				mem_read = 0;
				mem_write = 0;
				alu_control = 4'b0010; // ADD
			end
			7'b0000011: begin // Load
				reg_write = 1;
				mem_read = 1;
				mem_write = 0;
				alu_control = 4'b0010; // ADD
			end
			7'b0100011: begin // Store
				reg_write = 0;
				mem_read = 0;
				mem_write = 1;
				alu_control = 4'b0010; // ADD
			end
			// 其他操作...
			default: begin
				reg_write = 0;
				mem_read = 0;
				mem_write = 0;
				alu_control = 4'b0000; // NO OP
			end
		endcase
	end
endmodule
```

#### 7. 整合 CPU 模組

最後，我們將所有子模組整合到主 CPU 模組中：

```verilog
module riscv_cpu (
	input clk,
	input reset,
	output [31:0] result
);
	wire [31:0] instruction;
	wire [31:0] read_data1, read_data2;
	wire [31:0] alu_result;
	wire [31:0] read_data;
	wire reg_write, mem_read, mem_write;
	wire [3:0] alu_control;
	wire [4:0] write_reg;

	instruction_memory im (
		.address(pc), // 假設已經有 PC 管理
		.instruction(instruction)
	);

	data_memory dm (
		.clk(clk),
		.address(alu_result),
		.write_data(read_data2),
		.mem_read(mem_read),
		.mem_write(mem_write),
		.read_data(read_data)
	);

	register_file rf (
		.clk(clk),
		.read_reg1(instruction[19:15]),
		.read_reg2(instruction[24:20]),
		.write_reg(write_reg),
		.write_data(alu_result),
		.reg_write(reg_write),
		.read_data1(read_data1),
		.read_data2(read_data2)
	);

	alu alu (
		.input1(read_data1),
		.input2(read_data2),
		.alu_control(alu_control),
		.result(alu_result)
	);

	control_unit cu (
		.opcode(instruction[6:0]),
		.reg_write(reg_write),
		.mem_read(mem_read),
		.mem_write(mem_write),
		.alu_control(alu_control)
	);

	assign result = alu_result; // 輸出結果
endmodule
```

### 小結

在本節中，我們詳細介紹了如何使用 Verilog 實現 RISC-V 單週期處理器的各個組件，包括指令記憶體、資料記憶體、寄存器檔、ALU 和控制單元。透過這些模組的組合，形成了一個簡單的 CPU 模組，可以執行基本的 RISC-V 指令。在接下來的章節中，我們將探討如何利用 Icarus Verilog 對這個設計進行模擬和驗證。